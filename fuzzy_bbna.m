function [decision, desirability_score] = fuzzy_bbna(carla_outputs)
% FUZZY_BBNA - Decides whether to switch between autopilot and manual mode using fuzzy logic.
% This function implements a Behavior-Based Navigation Algorithm (BBNA) decider.
%
% Syntax: [decision, desirability_score] = fuzzy_bbna(carla_outputs)
%
% Inputs:
%   carla_outputs - A struct containing all processed data from the
%                   CARLA simulation environment, as generated by
%                   carla_udp_receiver.m. It must contain the fields:
%                   - network_status
%                   - sensor_fusion_status
%                   - processed_sensor_data
%                   - fallback_initiation
%                   - driver_attention
%                   - driver_readiness
%
% Outputs:
%   decision            - A string, either 'AUTOPILOT' or 'MANUAL'.
%   desirability_score  - The raw numeric output [0-100] from the FIS,
%                         representing the "desirability" of autopilot mode.

% --- Create or Load the Fuzzy Inference System (FIS) ---
% For performance, you could save the created FIS to a .fis file:
% >> savefis(fis, 'bbna_controller.fis');
% And then load it:
% >> fis = readfis('bbna_controller.fis');
% However, as requested, we create it from scratch here.
fis = create_bbna_fis();

% --- Pre-process CARLA data into fuzzy inputs ---
inputs = preprocess_carla_data(carla_outputs);

% --- Evaluate the FIS ---
% The evalfis function takes the FIS and the vector of processed inputs
% and returns the final defuzzified output value.
desirability_score = evalfis(fis, inputs);

% --- Make a Crisp Decision ---
% Based on the desirability score, we output a clear command. The thresholds
% create a hysteresis-like effect to prevent rapid switching.
% A score over 65 is a clear vote for Autopilot.
% A score under 35 is a clear vote for Manual.
% The middle 'Handover' zone defaults to the safer option: MANUAL.
if desirability_score > 65
    decision = 'AUTOPILOT';
else
    decision = 'MANUAL';
end

fprintf('Fuzzy BBNA: Score=%.2f -> Decision=%s\n', desirability_score, decision);

end


%% =======================================================================
%                     FIS CREATION
% ========================================================================
function fis = create_bbna_fis()
    % Defines the structure, membership functions, and rules for the FIS.
    fis = mamfis('Name', 'BBNA_Mode_Switcher');

    % --- 1. Add Inputs ---
    fis = addInput(fis, [0 1], 'Name', 'SystemHealth');
    fis = addInput(fis, [0 1], 'Name', 'EnvironmentalComplexity');
    fis = addInput(fis, [0 1], 'Name', 'DriverState');
    fis = addInput(fis, [0 1], 'Name', 'CriticalEvent');

    % --- 2. Add Membership Functions (MFs) for Inputs ---
    % SystemHealth MFs
    fis = addMF(fis, 'SystemHealth', 'trapmf', [0 0 0.2 0.4], 'Name', 'Poor');
    fis = addMF(fis, 'SystemHealth', 'trimf', [0.3 0.5 0.7], 'Name', 'Degraded');
    fis = addMF(fis, 'SystemHealth', 'trapmf', [0.6 0.8 1 1], 'Name', 'Good');

    % EnvironmentalComplexity MFs
    fis = addMF(fis, 'EnvironmentalComplexity', 'trapmf', [0 0 0.2 0.4], 'Name', 'Low');
    fis = addMF(fis, 'EnvironmentalComplexity', 'trimf', [0.3 0.5 0.7], 'Name', 'Moderate');
    fis = addMF(fis, 'EnvironmentalComplexity', 'trapmf', [0.6 0.8 1 1], 'Name', 'High');

    % DriverState MFs
    fis = addMF(fis, 'DriverState', 'trapmf', [0 0 0.2 0.4], 'Name', 'Unready');
    fis = addMF(fis, 'DriverState', 'trimf', [0.3 0.6 0.9], 'Name', 'Attentive');
    fis = addMF(fis, 'DriverState', 'trapmf', [0.7 0.9 1 1], 'Name', 'Ready');

    % CriticalEvent MFs (near-crisp)
    fis = addMF(fis, 'CriticalEvent', 'trapmf', [0 0 0.05 0.1], 'Name', 'None');
    fis = addMF(fis, 'CriticalEvent', 'trapmf', [0.9 0.95 1 1], 'Name', 'Occurred');
    
    % --- 3. Add Output ---
    fis = addOutput(fis, [0 100], 'Name', 'AutopilotDesirability');

    % --- 4. Add MFs for Output ---
    fis = addMF(fis, 'AutopilotDesirability', 'trapmf', [0 0 20 35], 'Name', 'Manual');
    fis = addMF(fis, 'AutopilotDesirability', 'trimf', [30 50 70], 'Name', 'Handover');
    fis = addMF(fis, 'AutopilotDesirability', 'trapmf', [65 80 100 100], 'Name', 'Autopilot');

    % --- 5. Add Rules ---
    % Rule format: [SysHealth EnvComplex DriverState CriticalEvent -> Output (Weight) (AND=1/OR=2)]
    rules = [
        % Critical Overrides (highest priority)
        0 0 0 2  1 1 1;  % IF (CriticalEvent is Occurred) THEN (Output is Manual)
        1 0 0 0  1 1 1;  % IF (SystemHealth is Poor) THEN (Output is Manual)

        % Driver-centric Rules
        3 0 3 1  1 1 1;  % IF (SystemHealth is Good) AND (DriverState is Ready) AND (CriticalEvent is None) THEN (Output is Manual)
        3 0 1 1  3 1 1;  % IF (SystemHealth is Good) AND (DriverState is Unready) AND (CriticalEvent is None) THEN (Output is Autopilot)
        2 0 1 1  2 1 1;  % IF (SystemHealth is Degraded) AND (DriverState is Unready) AND (CriticalEvent is None) THEN (Output is Handover)

        % Environment-centric Rules
        3 1 0 1  3 1 1;  % IF (SystemHealth is Good) AND (EnvComplexity is Low) AND (CriticalEvent is None) THEN (Output is Autopilot)
        0 3 0 1  2 1 1;  % IF (EnvComplexity is High) AND (CriticalEvent is None) THEN (Output is Handover)
        2 2 0 1  2 1 1;  % IF (SystemHealth is Degraded) AND (EnvComplexity is Moderate) AND (CriticalEvent is None) THEN (Output is Handover)
        
        % General safety rules
        2 1 0 1  2 1 1;  % IF (SystemHealth is Degraded) AND (EnvComplexity is Low) AND (CriticalEvent is None) THEN (Output is Handover)
    ];

    fis = addRule(fis, rules);
end


%% =======================================================================
%                     DATA PRE-PROCESSING
% ========================================================================
function processed_inputs = preprocess_carla_data(outputs)
    % Extracts and calculates the four key metrics for the FIS from the raw
    % CARLA output struct.

    % --- 1. Calculate SystemHealth [0-1] ---
    health_score = outputs.sensor_fusion_status.health_score;
    % Normalize uncertainty: assume trace > 10 is very bad.
    uncertainty = outputs.sensor_fusion_status.position_uncertainty;
    uncertainty_penalty = min(1, uncertainty / 10.0);
    % Final health is the base score, penalized by high uncertainty.
    SystemHealth = health_score * (1 - uncertainty_penalty);


    % --- 2. Calculate EnvironmentalComplexity [0-1] ---
    weather_severity = outputs.processed_sensor_data.Weather_Severity;
    % Normalize obstacle density: assume > 20 nearby obstacles is max density.
    obstacle_density = min(1, outputs.processed_sensor_data.Obstacle_Density / 20.0);
    % Final complexity is a weighted average. Weather is more impactful.
    EnvironmentalComplexity = (0.6 * weather_severity) + (0.4 * obstacle_density);

    
    % --- 3. Calculate DriverState [0-1] ---
    attention = outputs.driver_attention;
    readiness = outputs.driver_readiness;
    % Driver state is high only if both readiness and attention are high.
    DriverState = attention * readiness;
    
    
    % --- 4. Calculate CriticalEvent [0-1] ---
    % A critical event is a fallback command from the FDIR or a collision.
    is_fallback = outputs.fallback_initiation;
    is_collision = outputs.processed_sensor_data.is_collision_event;
    CriticalEvent = double(is_fallback || is_collision);

    % --- Assemble final input vector for evalfis ---
    processed_inputs = [SystemHealth, EnvironmentalComplexity, DriverState, CriticalEvent];
end